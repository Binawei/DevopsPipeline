name: Setup and Deploy Project

on:
  workflow_call:
    inputs:
      project_name:
        required: true
        type: string
      app_type:
        required: true
        type: string
      aws_region:
        required: false
        type: string
        default: "us-east-1"
      enable_database:
        required: false
        type: boolean
        default: false
      database_type:
        required: false
        type: string
        default: "postgres"
      database_instance_class:
        required: false
        type: string
        default: "db.t3.micro"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      EC2_SSH_KEY:
        required: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production-approval
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 17
      if: inputs.app_type == 'java-spring-boot'
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Set up Node.js
      if: inputs.app_type == 'react-frontend' || inputs.app_type == 'node-backend'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Run tests (Java)
      if: inputs.app_type == 'java-spring-boot'
      run: ./mvnw clean test
    
    - name: Build application (Java)
      if: inputs.app_type == 'java-spring-boot'
      run: ./mvnw clean package -DskipTests
    
    - name: Install dependencies (Node)
      if: inputs.app_type == 'react-frontend' || inputs.app_type == 'node-backend'
      run: npm ci
    
    - name: Run tests (Node)
      if: inputs.app_type == 'react-frontend' || inputs.app_type == 'node-backend'
      run: npm test -- --coverage --watchAll=false
    
    - name: Build application (React)
      if: inputs.app_type == 'react-frontend'
      run: npm run build
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.aws_region }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build and push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names ${{ inputs.project_name }} || aws ecr create-repository --repository-name ${{ inputs.project_name }}
        
        # Build and push image
        docker build -t $ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG $ECR_REGISTRY/${{ inputs.project_name }}:latest
        docker push $ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ inputs.project_name }}:latest
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
    
    - name: Deploy infrastructure with Terraform
      env:
        TF_VAR_project_name: ${{ inputs.project_name }}
        TF_VAR_app_type: ${{ inputs.app_type }}
        TF_VAR_aws_region: ${{ inputs.aws_region }}
        TF_VAR_enable_database: ${{ inputs.enable_database }}
        TF_VAR_database_type: ${{ inputs.database_type }}
        TF_VAR_database_instance_class: ${{ inputs.database_instance_class }}
      run: |
        cd devops/terraform
        terraform init
        terraform plan
        terraform apply -auto-approve
        
        # Get outputs
        echo "LOAD_BALANCER_DNS=$(terraform output -raw load_balancer_dns)" >> $GITHUB_ENV
        echo "ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url)" >> $GITHUB_ENV
    
    - name: Ensure Auto Scaling Group has instances
      run: |
        # Check current Auto Scaling Group status
        echo "Checking Auto Scaling Group status..."
        ASG_STATUS=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names "${{ inputs.project_name }}-asg" \
          --query 'AutoScalingGroups[0].[MinSize,MaxSize,DesiredCapacity]' \
          --output text)
        
        echo "ASG Status (Min/Max/Desired): $ASG_STATUS"
        
        # Get current min size and set desired capacity accordingly
        MIN_SIZE=$(echo "$ASG_STATUS" | cut -f1)
        echo "Setting desired capacity to minimum size: $MIN_SIZE"
        
        aws autoscaling update-auto-scaling-group \
          --auto-scaling-group-name "${{ inputs.project_name }}-asg" \
          --desired-capacity $MIN_SIZE
        
        echo "Waiting for instances to launch..."
        sleep 60
    
    - name: Get EC2 instance IPs and create inventory
      run: |
        # Get Auto Scaling Group instances (retry logic)
        for i in {1..5}; do
          echo "Attempt $i: Getting Auto Scaling Group instances..."
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "${{ inputs.project_name }}-asg" \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          echo "Instance IDs: $INSTANCE_IDS"
          
          if [ -n "$INSTANCE_IDS" ]; then
            break
          fi
          
          echo "No running instances found, waiting 30 seconds..."
          sleep 30
        done
        
        if [ -z "$INSTANCE_IDS" ]; then
          echo "No running instances found after retries"
          exit 1
        fi
        
        # Get public IPs of instances
        echo "Getting public IP addresses..."
        IPS=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_IDS \
          --query 'Reservations[].Instances[].PublicIpAddress' \
          --output text)
        
        echo "Public IPs: $IPS"
        
        # Create dynamic inventory
        echo "[production]" > devops/ansible/dynamic-inventory
        i=1
        for ip in $IPS; do
          if [ "$ip" != "None" ] && [ -n "$ip" ]; then
            echo "$ip ansible_user=ec2-user" >> devops/ansible/dynamic-inventory
            i=$((i+1))
          fi
        done
        echo "" >> devops/ansible/dynamic-inventory
        echo "[production:vars]" >> devops/ansible/dynamic-inventory
        echo "environment=production" >> devops/ansible/dynamic-inventory
        
        echo "Generated inventory:"
        cat devops/ansible/dynamic-inventory
    
    - name: Deploy to EC2 with Ansible
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Install Ansible
        pip install ansible
        
        # Create SSH key file
        echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/ssh_key
        chmod 600 /tmp/ssh_key
        
        # Deploy application
        cd devops/ansible
        ansible-playbook -i dynamic-inventory deploy.yml \
          --extra-vars "image_tag=$IMAGE_TAG environment=production project_name=${{ inputs.project_name }} app_type=${{ inputs.app_type }}" \
          --private-key /tmp/ssh_key \
          --ssh-common-args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
    
    - name: Output deployment info
      run: |
        echo "🎉 Deployment completed successfully!"
        echo "🌐 Application URL: http://${{ env.LOAD_BALANCER_DNS }}"
        echo "📦 Docker Image: ${{ env.ECR_REPOSITORY_URL }}:${{ github.sha }}"