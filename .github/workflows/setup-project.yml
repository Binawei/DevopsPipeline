name: Setup and Deploy Project

on:
  workflow_call:
    inputs:
      project_name:
        required: true
        type: string
      app_type:
        required: true
        type: string
        description: 'Backend application type (java-spring-boot or node-backend)'
      aws_region:
        required: false
        type: string
        default: "us-east-1"
      enable_database:
        required: false
        type: boolean
        default: false
      database_type:
        required: false
        type: string
        default: "postgres"
      database_instance_class:
        required: false
        type: string
        default: "db.t3.micro"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production-approval
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 17
      if: inputs.app_type == 'java-spring-boot'
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Set up Node.js
      if: inputs.app_type == 'node-backend'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Run tests (Java)
      if: inputs.app_type == 'java-spring-boot'
      run: ./mvnw clean test
    
    - name: Build application (Java)
      if: inputs.app_type == 'java-spring-boot'
      run: ./mvnw clean package -DskipTests
    
    - name: Install dependencies (Node)
      if: inputs.app_type == 'node-backend'
      run: npm ci
    
    - name: Run tests (Node)
      if: inputs.app_type == 'node-backend'
      run: npm test -- --coverage --watchAll=false
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.aws_region }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build and push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names ${{ inputs.project_name }} || aws ecr create-repository --repository-name ${{ inputs.project_name }}
        
        # Build and push image
        docker build -t $ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG $ECR_REGISTRY/${{ inputs.project_name }}:latest
        docker push $ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ inputs.project_name }}:latest
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
    
    - name: Check if ECS services already exist
      run: |
        # Check for existing ECS cluster and service
        EXISTING_CLUSTER=$(aws ecs describe-clusters \
          --clusters ${{ inputs.project_name }}-cluster \
          --query 'clusters[0].status' \
          --output text 2>/dev/null || echo "MISSING")
        
        echo "Existing cluster status: $EXISTING_CLUSTER"
        
        if [ "$EXISTING_CLUSTER" = "ACTIVE" ]; then
          echo "CLUSTER_EXISTS=true" >> $GITHUB_ENV
          echo "Found existing ECS cluster, will update service"
        else
          echo "CLUSTER_EXISTS=false" >> $GITHUB_ENV
          echo "No existing cluster, Terraform will create new infrastructure"
        fi
    
    - name: Deploy infrastructure with Terraform
      env:
        TF_VAR_project_name: ${{ inputs.project_name }}
        TF_VAR_app_type: ${{ inputs.app_type }}
        TF_VAR_aws_region: ${{ inputs.aws_region }}
        TF_VAR_enable_database: ${{ inputs.enable_database }}
        TF_VAR_database_type: ${{ inputs.database_type }}
        TF_VAR_database_instance_class: ${{ inputs.database_instance_class }}
        TF_VAR_image_uri: ${{ steps.login-ecr.outputs.registry }}/${{ inputs.project_name }}:${{ github.sha }}
      run: |
        cd devops/terraform
        terraform init
        terraform plan
        terraform apply -auto-approve
        
        # Get outputs
        echo "LOAD_BALANCER_DNS=$(terraform output -raw load_balancer_dns)" >> $GITHUB_ENV
        echo "ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url)" >> $GITHUB_ENV
        echo "ECS_CLUSTER_NAME=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_ENV
        echo "ECS_SERVICE_NAME=$(terraform output -raw ecs_service_name)" >> $GITHUB_ENV

    - name: Deploy to ECS Fargate
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create new task definition with updated image
          TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition ${{ inputs.project_name }} --query 'taskDefinition')
          
          # Write to temporary file and process
          echo "$TASK_DEFINITION" > /tmp/task-def.json
          
          # Update image and clean metadata
          jq --arg IMAGE "$ECR_REGISTRY/${{ inputs.project_name }}:$IMAGE_TAG" '
          .containerDefinitions[0].image = $IMAGE |
          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy, .tags)
          ' /tmp/task-def.json > /tmp/new-task-def.json
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file:///tmp/new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)

        echo "New task definition: $NEW_TASK_DEF_ARN"

        # Update ECS service with new task definition
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER_NAME }} \
          --service ${{ env.ECS_SERVICE_NAME }} \
          --task-definition $NEW_TASK_DEF_ARN

        # Wait for deployment to complete
        echo "Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER_NAME }} \
          --services ${{ env.ECS_SERVICE_NAME }}

        echo "ECS deployment completed successfully!"
    
    - name: Output deployment info
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "üåê Application URL: http://${{ env.LOAD_BALANCER_DNS }}"
        echo "üì¶ Docker Image: ${{ env.ECR_REPOSITORY_URL }}:${{ github.sha }}"
        echo "üöÄ ECS Cluster: ${{ env.ECS_CLUSTER_NAME }}"
        echo "‚öôÔ∏è ECS Service: ${{ env.ECS_SERVICE_NAME }}"